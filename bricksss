<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bricksss</title>
  <style>
    /* Basic Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body, html {
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      user-select: none;
    }

    canvas {
      display: block;
      background: #111;
      margin: 60px auto 0 auto; /* leave space for HUD */
      border-radius: 8px;
      max-width: 100vw;
      max-height: 80vh;
      touch-action: none; /* for mobile touch */
    }

    /* HUD */
    #hud {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(10, 10, 10, 0.85);
      color: #fff;
      display: flex;
      justify-content: space-between;
      padding: 10px 20px;
      font-size: 1.2em;
      font-family: 'Segoe UI', sans-serif;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #hud div {
      user-select: none;
    }

    /* Overlay Screens */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(#111 20%, #000 100%);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      padding: 20px;
      text-align: center;
    }
    .overlay.hidden {
      display: none;
    }

    /* Game Title */
    .game-title {
      font-size: 4rem;
      font-weight: bold;
      letter-spacing: 4px;
      color: #ff6f00;
      text-shadow: 2px 2px 10px #ffa000;
      margin-bottom: 30px;
    }

    /* Buttons */
    .menu-btn {
      background: #ff6f00;
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.2rem;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(255, 111, 0, 0.5);
      transition: transform 0.2s ease, background 0.3s ease;
      margin-top: 20px;
      min-width: 150px;
    }
    .menu-btn:hover {
      transform: scale(1.05);
      background: #ff8f00;
    }

    /* Game Over Stats */
    #game-over-screen p {
      margin: 10px 0;
      font-size: 1.1rem;
    }

  </style>
</head>
<body>

  <!-- HUD -->
  <div id="hud">
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <div id="lives">Lives: 3</div>
  </div>

  <!-- Start Screen -->
  <div id="start-screen" class="overlay">
    <h1 class="game-title">Bricksss</h1>
    <button id="start-btn" class="menu-btn">Start Game</button>
  </div>

  <!-- Game Over Screen -->
  <div id="game-over-screen" class="overlay hidden">
    <h2>Game Over</h2>
    <p id="final-score">Score: 0</p>
    <p id="bricks-broken">Bricks Broken: 0</p>
    <p id="lives-used">Lives Used: 0</p>
    <button id="restart-btn" class="menu-btn">Restart</button>
  </div>

  <canvas id="gameCanvas" width="480" height="320"></canvas>

  <script>
    // === CANVAS SETUP ===
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // HUD Elements
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');

    // Screens
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScore = document.getElementById('final-score');
    const bricksBrokenText = document.getElementById('bricks-broken');
    const livesUsedText = document.getElementById('lives-used');

    // === GAME VARIABLES ===
    let score = 0;
    let lives = 3;
    let level = 1;
    let bricksBroken = 0;
    let bricks = [];

    // BALL
    const ball = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      radius: 8,
      dx: 4,
      dy: -4,
      speedIncrement: 0.5
    };

    // PADDLE
    const paddle = {
      width: 80,
      height: 12,
      x: canvas.width / 2 - 40,
      y: canvas.height - 30,
      speed: 8,
      movingLeft: false,
      movingRight: false
    };

    // BRICK CONFIGURATION
    let brickRowCount = 3;
    let brickColumnCount = 7;
    const brickWidth = 55;
    const brickHeight = 20;
    const brickPadding = 8;
    const brickOffsetTop = 50;
    const brickOffsetLeft = 35;

    // --- BRICK COLORS AND HIT POINTS ---
    const colors = ['#FF5733', '#FFC300', '#DAF7A6']; // For hits 3 to 1

    // --- TOUCH SUPPORT ---
    let touchX = null;

    // AUDIO CONTEXT FOR SOUND
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // === FUNCTIONS ===

    // Init bricks for current level
    function initBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = {
            x: 0,
            y: 0,
            hits: Math.min(level, 3), // max 3 hits per brick, scaled by level
            broken: false,
            hitFlash: 0 // for animation frames
          };
        }
      }
    }

    // Draw bricks with hit animation color change
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (!b.broken) {
            const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            b.x = brickX;
            b.y = brickY;

            // Color based on hits remaining (1 to 3)
            let colorIndex = b.hits - 1;
            if (colorIndex < 0) colorIndex = 0;
            let color = colors[colorIndex];

            // Flash effect on hit
            if (b.hitFlash > 0) {
              color = '#FFFFFF'; // white flash
              b.hitFlash--;
            }

            // Draw brick
            ctx.fillStyle = color;
            ctx.fillRect(brickX, brickY, brickWidth, brickHeight);

            // Brick border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
          }
        }
      }
    }

    // Draw paddle
    function drawPaddle() {
      ctx.fillStyle = '#ff6f00';
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
      // Paddle shadow for style
      ctx.shadowColor = '#ffa000';
      ctx.shadowBlur = 15;
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
      ctx.shadowBlur = 0;
    }

    // Draw ball
    function drawBall() {
      ctx.beginPath();
      const gradient = ctx.createRadialGradient(ball.x, ball.y, ball.radius/2, ball.x, ball.y, ball.radius);
      gradient.addColorStop(0, '#fff');
      gradient.addColorStop(1, '#ff6f00');
      ctx.fillStyle = gradient;
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }

    // Play sound on brick hit
    function playHitSound() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(440 + Math.random() * 200, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    // Update ball position & collision detection
    function updateBall() {
      ball.x += ball.dx;
      ball.y += ball.dy;

      // Wall collisions
      if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
        ball.dx = -ball.dx;
      }
      if (ball.y - ball.radius < 0) {
        ball.dy = -ball.dy;
      }

      // Paddle collision
      if (ball.y + ball.radius > paddle.y &&
          ball.x > paddle.x &&
          ball.x < paddle.x + paddle.width) {
        ball.dy = -ball.dy;

        // Adjust ball dx based on where it hits paddle for control
        let hitPos = ball.x - (paddle.x + paddle.width / 2);
        ball.dx = hitPos * 0.15;
      }

      // Brick collisions
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (!b.broken) {
            if (ball.x > b.x && ball.x < b.x + brickWidth &&
                ball.y - ball.radius < b.y + brickHeight && ball.y + ball.radius > b.y) {
              ball.dy = -ball.dy;

              // Brick hit
              b.hits--;
              b.hitFlash = 3; // frames to flash

              if (b.hits <= 0) {
                b.broken = true;
                score += 10;
                bricksBroken++;
                updateHUD();
              }

              playHitSound();
            }
          }
        }
      }

      // Bottom collision: lose life or game over
      if (ball.y + ball.radius > canvas.height) {
        lives--;
        updateHUD();

        if (lives <= 0) {
          showGameOver();
        } else {
          resetBall();
        }
      }
    }

    // Update paddle position (keyboard & touch)
    function updatePaddle() {
      if (paddle.movingLeft) {
        paddle.x -= paddle.speed;
      } else if (paddle.movingRight) {
        paddle.x += paddle.speed;
      }

      // Touch control override
      if (touchX !== null) {
        paddle.x = touchX - paddle.width / 2;
      }

      // Keep paddle in bounds
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
    }

    // Draw everything
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBricks();
      drawPaddle();
      drawBall();
    }

    // Update HUD
    function updateHUD() {
      scoreEl.textContent = `Score: ${score}`;
      livesEl.textContent = `Lives: ${lives}`;
      levelEl.textContent = `Level: ${level}`;
    }

    // Reset ball and paddle positions
    function resetBall() {
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 60;
      ball.dx = 4 * (Math.random() > 0.5 ? 1 : -1);
      ball.dy = -4 - (level - 1) * 0.5; // faster at higher levels

      paddle.x = canvas.width / 2 - paddle.width / 2;
    }

    // Advance level (increase difficulty)
    function nextLevel() {
      level++;
      bricksBroken = 0;
      lives = Math.min(lives + 1, 5); // bonus life max 5
      ball.dx = 4 + (level - 1) * 0.5;
      ball.dy = -(4 + (level - 1) * 0.5);

      // Increase bricks rows (max 6)
      brickRowCount = Math.min(3 + Math.floor(level / 2), 6);

      initBricks();
      resetBall();
      updateHUD();
    }

    // Check if all bricks broken
    function checkLevelClear() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (!bricks[c][r].broken) return false;
        }
      }
      return true;
    }

    // Game Loop
    let animationId;
    function gameLoop() {
      updatePaddle();
      updateBall();

      if (checkLevelClear()) {
        nextLevel();
      }

      draw();

      animationId = requestAnimationFrame(gameLoop);
    }

    // Show Game Over screen
    function showGameOver() {
      cancelAnimationFrame(animationId);

      finalScore.textContent = `Score: ${score}`;
      bricksBrokenText.textContent = `Bricks Broken: ${bricksBroken}`;
      livesUsedText.textContent = `Lives Used: ${3 - lives}`;

      gameOverScreen.classList.remove('hidden');
    }

    // Start Game
    function startGame() {
      score = 0;
      lives = 3;
      level = 1;
      bricksBroken = 0;
      brickRowCount = 3;

      initBricks();
      resetBall();
      updateHUD();

      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');

      animationId = requestAnimationFrame(gameLoop);
    }

    // Keyboard Controls
    document.addEventListener('keydown', e => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') paddle.movingLeft = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') paddle.movingRight = true;
    });
    document.addEventListener('keyup', e => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') paddle.movingLeft = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') paddle.movingRight = false;
    });

    // Touch Controls for mobile
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      touchX = e.touches[0].clientX - rect.left;
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      touchX = e.touches[0].clientX - rect.left;
    });
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      touchX = null;
    });

    // Buttons
    document.getElementById('start-btn').addEventListener('click', () => {
      audioCtx.resume(); // to allow sound after user interaction
      startGame();
    });

    document.getElementById('restart-btn').addEventListener('click', () => {
      audioCtx.resume();
      startGame();
    });

  </script>

</body>
</html>
